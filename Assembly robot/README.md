### 这是个啥？

这里是省赛装配小车的工程文件

### 目录

- 串口调试程序
  - 用于机械臂粗调的程序
- 通信范本
  - 这里是舵机控制板和底盘控制板之间使用的通信程序....的使用实例
- 机械臂模板框架
  - 里面是一份没有填入动作组的机械臂程序框架
- 底盘框架模板
  - 控制小车走完大体流程的底盘代码  
- 技术路线
  - 关于小车车的细节部分,你需要一个XMind来阅读里面的内容
- image
  - 里面是本篇README所用的图像

### 详细说明

#### 1.串口调试部分

使用Arduino内置串口监视器连接控制板，并通过命令行交互  
![串口调试程序详解.png](image/串口调试程序详解.png)  

例如，输入 `to 2` 切换到2号舵机  
再输入 `set 20` 将2号舵机设置到20°  
使用 `show list` 打印当前机械臂所有舵机的角度

#### 2.通信范本
单纯是一个利用RX,TX串口实现通信的函数封装  
可以更改内部的 `".Go.\"`  来更改通信约定的串口信息，当然收发信的函数都要改。  
~~讲道理，那是你的事，跟我没有关系，这个信息本来就是我定义的~~

接线尤其需要注意！！！！！  

![双板通信接线方法](image/双板通信接线方法.jpg)

当多板通信的时候可以接成以下状态,但是需要约定不同的收发信息  

![多板通信接线](image/多板通信接线.png)  

使用模拟口通信的时候稍加更改即可使用
### 3.机械臂框架模板
主体概览:  

![机械臂范本封装概览](image/机械臂范本封装概览.png)  

源码内注释比较详细，主体上是需要修改如下函数封装的定义:  
```Arduino
    //机械臂的初始化位置
    void resetServoChain();
    //装配台抓取
    void Catch_Item(uint8_t WhichOne);
    //从存储区抓取
    void Catch_Item_From_Storage(uint8_t WhichOne);
    //投放装配体
    void PutItem(uint8_t WhichOne);

    //综上，内部需要使用Move()实现各种动作组，并填充case标签
```
**需要注意的是**  
`Move(angle_Setting angle_s,unsigned long defdelay,speed_Setting* speed_s=NULL)`  
是一个泛用性很强的封装，根据配置结构体传参的写法会非常灵活，稍加更改即可用于多种机械臂的运动  

其内部的实现逻辑大概是如下：  
  
首先,我们需要认识两个简单的结构体
```Arduino
//机械臂角度配置结构体,用于Move()
struct angle_Setting
{
    uint8_t Servo0_angle;
    uint8_t Servo1_angle;
    uint8_t Servo2_angle;
    uint8_t Servo3_angle;
    uint8_t Servo4_angle;
    uint8_t Servo5_angle;
};

//机械臂速度配置结构体,用于Move()的可选参数
//决定每个舵机移动时的时延
struct speed_Setting
{
    uint8_t Servo0_delay;
    uint8_t Servo1_delay;
    uint8_t Servo2_delay;
    uint8_t Servo3_delay;
    uint8_t Servo4_delay;
    uint8_t Servo5_delay;
};
```
简单来说, `angle_Setting` 是期望移动到某个姿态时机械臂所有舵机的角度集合,而 `speed_Setting` 则是将舵机移动到这个期望角度合集时每个舵机每移动1°的时延.....的集合。  
~~说白了就是两坨的数字打包~~  

其中, `Move()` 通过传入的 `angle_s` 设置结构体读取出期望的舵机角度，再依次将其与舵机串中各个舵机的当前角度进行比较，每次进行1°的修正，当其修正到目标值时则跳过对其的遍历，直到所有的舵机达到期望值。  

可选参数 `speed_s` 存在时，依次读取每个舵机期望在移动时的时延并进行时延，否则进行默认时常为 `defdelay` 的时延。 

**注意**，`speed_s` 是一个速度设置文件的**指针**，之所以用指针传参，是因为这样比较好设置默认参数为NULL~~绝对不是因为我想不到别的办法~~，方便判断是否传入了可选的参数，所以传参的时候不要忘记使用 `&`。

**好了，来看个简单的例子**    

要进行移动，我们就需要新建一个期望的角度集合，我称之为角度配置结构体：  
```Arduino
angle_Setting standUP={90，90，90，90，90，90};
```
好了，现在我们有了一个将所有舵机移动到90°的配置结构,之所以叫 `standUP` 当然是因为这个角度下机械臂"站起来了",那么，如何进行移动?    
```Arduino
Move(standUP,20);
```
执行上述语句,会让机械臂移动到 `standUP` 配置的角度，并且每个舵机每进行1°的移动，就会 `delay(20)` 进行时延，是的，这就是第二个参数 `defdelay` 的作用，**但是**,它有一个 `def` 头衔，也就是说，当第三个可选参数 `speed_s` 传入时,它便不再发挥作用。  

什么时候需要用到 `speed_s` 呢，当然是希望每个舵机节点移动的角速度不一致、或者需要两个以上节点配合执行某些动作的时候,需要对舵机单独配速,例如,我们新建一个配速结构体 `How_To_Move`：  
```Arduino
speed_Setting How_To_Move={0,10,20,20,20,40};
```
随后，我们执行如下(不要忘记 `&`):
```Arduino
//defdelay会失去作用，所以怎么填都行，不过为了识别还是置0最好
Move(standUP,0,&How_To_Move);
```
即可让各个舵机按照我们设置的角度和速度来移动，其中，因为0号舵机的每度时延是0，所以它运动得非常快，而5号舵机移动得最慢。  

当然，你也可以通过结构体得修改方式来一个一个修改配置文件的值，而达到重复利用一个变量的目的，省去每次都要新建设置的功夫，例如如下:  
```Arduino
standUP.Servo0_angle=120;
How_To_Move.Servo0_delay=50;
```
即可对原有的设置结构体进行更改。  

**综上**，一个机械臂的好坏全靠动作组调参的好坏,调参需要非常细致的调试，并且，实现各个目标的策略也是决定动作好坏的非常重要的因素  
~~在不会过劳死的基础上奋力调试吧！！~~  
### 4.底盘框架模板
底盘框架的复用性非常非常强，基本没有需要更改的地方，只需要打磨一下小车的具体流程即可，关于封装，其实可以看看技术路线，它原本只是为了记录底盘框架所用封装信息而创建的，只是后来~~脑壳抽风~~突发奇想加入了其他东西融合成了一张大图，便出现在了这里。  

### 5.技术路线概览
真的就只是个概览，这张图里面包含的信息不一定是最新的  
~~但是我想起来的话还是会更新一下下~~
![技术路线概览](/LittleCarFixed/image/技术路线概览.png)
